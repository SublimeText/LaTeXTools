%YAML 1.2
---
name: LaTeXTools Log
scope: text.log.latex
version: 2

first_line_match: '^This is (?:LuaHB|pdfe?|Xe)?TeXk?, Version '

variables:
  drive_char: '[a-zA-Z]'
  file_name: '{{file_char}}+{{file_ext}}{{file_break}}'
  file_char: '[\w.-]'  # note: assume sane path names
  file_ext: '\.{{file_ext_start}}{{file_ext_char}}*'
  file_ext_start: '[a-zA-Z]'
  file_ext_char: '[a-zA-Z0-9]'
  file_break: (?:\n|(?=\s*[()]))

################################################################################

contexts:
  main:
    - include: comments
    - include: constants
    - include: blocks
    - include: brackets
    - include: log-entries
    - include: commands
    - include: strings

  comments:
    # note: primarily used for syntax_test files
    - match: ^\#
      scope: punctuation.definition.comment.log
      push: comment-body

  comment-body:
    - meta_scope: comment.line.log
    - match: $\n?
      pop: 1

###[ BLOCKS ]##################################################################

  blocks:
    - match: (?=\()
      branch_point: block
      branch:
        - block
        - paren

  block:
    - match: \(
      scope: punctuation.section.block.begin.log
      set:
        - block-body
        - block-path-begin

  block-path-begin:
    # possible UNC path, starting at eol
    - match: (\\)\n
      captures:
        1: punctuation.separator.path.log
      set:
        - block-unquoted-path
        - block-unquoted-path-expect-backslash
    # possible absolute posix path, starting at eol,
    # maybe followed by windows drive letter
    - match: (/)\n
      captures:
        1: punctuation.separator.path.log
      set:
        - block-unquoted-path
        - block-unquoted-path-expect-begin
    # possible windows drive letter at eol
    - match: (/?){{drive_char}}\n
      captures:
        1: punctuation.separator.path.log
      set:
        - block-unquoted-path
        - block-unquoted-path-expect-colon
    # possible posix relative path, starting at eol
    - match: \.\n
      set:
        - block-unquoted-path
        - block-unquoted-path-expect-segment
    # possible posix home path, starting at eol
    - match: ~\n
      set:
        - block-unquoted-path
        - block-unquoted-path-expect-slash
    # possible path, starting at next line
    - match: \n
      set:
        - block-path-begin-continuation
        - bol-pop
    - include: block-path-begin-continuation

  block-path-begin-continuation:
    # possible incomplete relative path or filename, starting at eol
    - match: '[\w-]+\.?\n'
      set:
        - block-unquoted-path-meta
        - block-unquoted-path-expect-file
    # quoted path
    - match: \"
      scope: punctuation.definition.entity.begin.log
      set: block-quoted-path
    # UNC path
    - match: \\\\
      scope: punctuation.separator.path.log
      set: block-unquoted-path
    # drive letter
    - match: '(/?){{drive_char}}(:[\\/]?)'
      captures:
        1: punctuation.separator.path.log
        2: punctuation.separator.path.log
      set: block-unquoted-path
    # posix home or absolute path
    - match: '~?(/)'
      captures:
        1: punctuation.separator.path.log
      set: block-unquoted-path
    # relative path
    - match: '{{file_char}}+([\\/])'
      captures:
        1: punctuation.separator.path.log
      set: block-unquoted-path
    # filename.ext
    - match: '{{file_name}}'
      set: block-unquoted-ext
    # not a path
    - match: ''
      fail: block

  block-quoted-path:
    - meta_scope: entity.name.section.filename.log
    - match: \"
      scope: punctuation.definition.entity.end.log
      pop: 1
    - match: '[:\\/]'
      scope: punctuation.separator.path.log

  block-unquoted-path-expect-backslash:
    # UNC path
    - match: ^\\(?![\\/])
      scope: punctuation.separator.path.log
      pop: 1
    # otherwise it is not a block
    - match: ^
      fail: block

  block-unquoted-path-expect-slash:
    # single posix path separator
    - match: ^/(?![\\/])
      scope: punctuation.separator.path.log
      pop: 1
    # otherwise it is not a block
    - match: ^
      fail: block

  block-unquoted-path-expect-begin:
    # drive letter
    - match: ^{{drive_char}}(:[\\/])
      captures:
        1: punctuation.separator.path.log
      pop: 1
    # expect file name or path
    - include: block-unquoted-path-expect-segment

  block-unquoted-path-expect-colon:
    # colon after drive letter
    - match: ^:[\\/]
      scope: punctuation.separator.path.log
      pop: 1
    # expect file name or path
    - include: block-unquoted-path-expect-segment

  block-unquoted-path-expect-file:
    # file name or extentions beginning with period
    - match: ^{{file_char}}*?{{file_ext}}{{file_break}}
      pop: 2
    # file extension without period
    - match: ^{{file_ext_char}}+{{file_break}}
      pop: 2
    # otherwise it is not a block
    - match: ^
      fail: block

  block-unquoted-path-expect-segment:
    # path segment
    - match: ^{{file_char}}*([\\/])
      captures:
        1: punctuation.separator.path.log
      pop: 1
    # consume very long file or folder name
    - match: ^[\w-]{79}\n
      set: block-unquoted-path-expect-segment
    - match: ^[\w.-]{79}\n
      pop: 1
    # file name or exteions beginning with period
    - match: ^{{file_char}}*?{{file_ext}}{{file_break}}
      pop: 1
    # otherwise it is not a block
    - match: ^
      fail: block

  block-unquoted-path-meta:
    - meta_scope: entity.name.section.filename.log

  block-unquoted-ext:
    - meta_scope: entity.name.section.filename.log
    # file name or exteions beginning with period
    - match: ^{{file_char}}*?{{file_ext}}{{file_break}}
      pop: 1
    # file extension without period
    - match: ^{{file_ext_char}}+{{file_break}}
      pop: 1
    - match: (?=[ \t()])
      pop: 1
    - match: ^
      pop: 1

  block-unquoted-path:
    - meta_scope: entity.name.section.filename.log
    # begin of normal block body
    - match: ^(?![{{file_char}}\\/]+{{file_break}})
      pop: 1
    - match: (?=[ \t()])
      pop: 1
    - match: '[\\/]'
      scope: punctuation.separator.path.log

  block-body:
    - meta_scope: meta.block.log
    - match: \)
      scope: punctuation.section.block.end.log
      pop: 1
    - include: main

  brackets:
    - match: \[
      scope: punctuation.section.brackets.begin.log
      push: bracket-body

  bracket-body:
    - meta_scope: meta.brackets.log
    - match: \]
      scope: punctuation.section.brackets.end.log
      pop: 1
    - include: comments
    - include: constants
    - include: brackets
    - include: parens
    - include: commands
    - include: strings

  parens:
    - match: \(
      scope: punctuation.section.parens.begin.log
      push: paren-body

  paren:
    - match: \(
      scope: punctuation.section.parens.begin.log
      set: paren-body

  paren-body:
    - meta_scope: meta.parens.log
    - match: \)
      scope: punctuation.section.parens.end.log
      pop: 1
    - include: comments
    - include: constants
    - include: brackets
    - include: parens
    - include: log-entries
    - include: commands
    - include: strings

###[ LOG ENTRIES ]##############################################################

  log-entries:
    # multi-line meta information, starting with exactly 79 chars
    - match: ^(?:Dictionary:.{68}|Document Class:.{64}|File:.{74}|Language:.{70}|Package:.{71})\n
      push: block-comment-body
    # single-line meta information
    - match: ^(?:Dictionary|Document Class|File|Language|Package):.+
      scope: comment.line.log
    # errors
    - match: '^[^:]*Error:'
      scope: markup.error.log
    - match: '^!.*'
      scope: markup.error.log
    # warnings
    - match: '^[^:]*(?:Overfull|Underfull)'
      scope: markup.warning.log
      embed: box-warning-content
      escape: \[\]$|(?=^\s*(?:\[(?:\d+|[^\]]+\])$)|Overfull|Underfull\b)
      escape_captures:
        0: meta.warning.box.log punctuation.terminator.log
    - match: '^[^:]*(?:Warning|warning \([^)]*\)):'
      scope: markup.warning.log
    - match: '^[^:]*:\d*:.*'
      scope: markup.warning.log
    # info
    - match: '^[^:]*(?:Info|Note|Summary):'
      scope: markup.info.log

  block-comment-body:
    - meta_scope: comment.line.log
    - match: ^.{79}\n  # consume anything which has 79 chars
    - match: \n
      pop: 1

  box-warning-content:
    - meta_scope: meta.warning.box.log
    - include: comments
    - include: constants
    - include: brackets
    - include: parens
    - include: commands
    - include: strings

  commands:
    - match: (\\)[\w@]+
      scope: support.function.latex
      captures:
        1: punctuation.definition.variable.latex
      push: cmd-args
    - match: :?=
      scope: keyword.operator.assignment.latex
      push: value
    - match: ;
      scope: punctuation.separator.latex

  cmd-args:
    - meta_scope: meta.function-call.latex
    - include: brackets
    - include: parens
    - match: \{
      scope: punctuation.section.braces.begin.log
      push: cmd-args-body
    - match: ''
      pop: 1

  cmd-args-body:
    - meta_scope: meta.braces.log
    - match: \}
      scope: punctuation.section.braces.end.log
      pop: 1
    - include: comments
    - include: constants
    - include: brackets
    - include: parens
    - include: commands
    - include: strings

  value:
    - include: parens
    - match: $|(?=\S)
      pop: 1

###[ STRINGS ]##################################################################

  constants:
    # copyright sign
    - match: \(C\)
    # consume plain window paths, to avoid segments being scoped latex commands
    - match: \b{{drive_char}}:(?:\\\S*)?\n
      push: path-continuation
    - match: \b{{drive_char}}:\\\S*

  path-continuation:
    - match: ^\S*
      pop: 1

  strings:
    - match: '{'
      scope: punctuation.definition.string.begin.log
      push: brace-quoted-string-body
    - match: '<<'
      scope: punctuation.definition.string.begin.log
      push: double-angled-string-body
    - match: '<'
      scope: punctuation.definition.string.begin.log
      push: single-angled-string-body
    - match: '``'
      scope: punctuation.definition.string.begin.log
      push: double-quoted-string-body
    - match: '`'
      scope: punctuation.definition.string.begin.log
      push: single-quoted-string-body
    # escaped characters
    - match: \\.

  brace-quoted-string-body:
    - meta_scope: string.quoted.other.log
    - match: '}'
      scope: punctuation.definition.string.end.log
      pop: 1
    - include: brace-quoted-nested-string-body

  brace-quoted-nested-string-body:
    - match: '}'
      pop: 1
    - match: '{'
      push: brace-quoted-nested-string-body
    - match: \\[{}]

  double-angled-string-body:
    - meta_scope: string.quoted.other.log
    - match: '>>'
      scope: punctuation.definition.string.end.log
      pop: 1
    - match: \\[<>]

  single-angled-string-body:
    - meta_scope: string.quoted.other.log
    - match: '>'
      scope: punctuation.definition.string.end.log
      pop: 1
    - match: \\[<>]

  double-quoted-string-body:
    - meta_scope: string.quoted.double.log
    - match: ''''''
      scope: punctuation.definition.string.end.log
      pop: 1
    - match: \.$
      scope: punctuation.definition.string.end.log
      pop: 1
    - match: \\\'

  single-quoted-string-body:
    - meta_scope: string.quoted.single.log
    - match: ''''
      scope: punctuation.definition.string.end.log
      pop: 1
    - match: \.$
      scope: punctuation.definition.string.end.log
      pop: 1
    - match: \\\'

###[ PROTOTYPES ]###############################################################

  bol-pop:
    - match: ^
      pop: 1
