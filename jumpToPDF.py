import sublime, sublime_plugin, os.path, subprocess, time, re
import getTeXRoot

# Jump to current line in PDF file

class jump_to_pdfCommand(sublime_plugin.TextCommand):
	# The following delimiters (and one regex) are hard-coded as they cover all cases 
	# I've encountered so far. If more cases crop up, they may warrant a user setting
	# via some preference file.
	re_lytex_opening = re.compile(r"\\begin(\[[A-Za-z0-9=., ]*\])?{lilypond}", re.IGNORECASE)
	lytex_opening_markers = ["\\begin{lilypond}"]
	lytex_closing_markers = ["\\end{lilypond}" + '\n']
	tex_opening_markers = ["{%" + '\n', "\\begin{quote}" + '\n']
	tex_closing_markers = ["}" + '\n', "\\end{quote}" + '\n']
	lily_packages = ["\\usepackage{graphics}" + '\n']

	# Remove whitespace characters, but not newlines, from string s. Convert s to lowercase.
	# Used to used to normalize .lytex and .tex files prior to scanning for Lilypond scopes.
	def filter_line(self, s):
		s = s.replace(' ', '')
		s = s.replace('\t', '')
		s = s.replace('\r', '').lower()
		return s

	# Look for the next occurence of at least one among "strings" in file "target" and 
	# assume that the current index of the file is at line "startpos".
	# Return the line number of that next occurence and the index of the matched delimiter (if applicable).
	def line_of_next_occurrence(self, target, startpos, strings):
		r = target.readline()
		r = self.filter_line(r)
		counter = startpos + 1 			# print "			scanning line: ", counter, ":  ", repr(r)
		while r:
			if r in strings:
				return counter, strings.index(r)
			if (self.re_lytex_opening.match(r)):
				return counter, 0
			r = target.readline()
			r = self.filter_line(r)
			counter = counter + 1 		# print "			scanning line: ", counter, ":  ", repr(r)
		return counter, 0

	# Attempt to map a line number in a .lytex file to its corresponding line number 
	# in the LilyPond-generated .tex file.
	def map_lytex2tex(self, old_line, fileName):
		# Ensure that both files (.tex and .lytex) are open. 
		tex = open(fileName + '.tex')
		lytex = open(fileName + '.lytex')

		# Initialize the line number offset (iteratively computed as "cur_sigma").
		cur_sigma = 0

		# Initialize line number registers: 
		# i, ii hold the line numbers opening and closing, respectively, the most recently scanned  "lilypond" environment in the .lytex file.
		# j, jj hold the line numbers opening and closing, respectively, the corresponding code block generated by lilypond-book in the .tex file.
		i = ii = j = jj = g = -1

		# Find the opening and closing line numbers of the next LilyPond hunk in the .tex and .lytex files. 
		while i < old_line:
			i, r = self.line_of_next_occurrence(lytex, ii, self.lytex_opening_markers)
			print "i = ", i, 'r = ', r, 'closing marker = ', self.lytex_closing_markers[r].split(' ')
			ii, r = self.line_of_next_occurrence(lytex, i, self.lytex_closing_markers[r].split(' '))
			print "ii = ", ii
			j, r = self.line_of_next_occurrence(tex, jj, self.tex_opening_markers)
			print "j = ", j
			jj, r = self.line_of_next_occurrence(tex, j, self.tex_closing_markers[r].split(' '))
			print "jj = ", jj
			cur_sigma = cur_sigma + (ii - i - (jj - j))
			print "cur_sigma = ", cur_sigma

		# The previous loop has stopped at the Lilypond hunk immediately following the cursor. Revoke the last iteration to account only for hunks before the cursor.
		cur_sigma = cur_sigma - (ii - i - (jj - j))		# print "cur_sigma (adjusted) = ", cur_sigma

		# Preliminarily calculate at which line the old_line of the .texly maps into the .tex.
		mapping = old_line - cur_sigma

		# Find line where Lilypond has injected \usepackage{graphics} into the .tex file.
		tex.seek(0)
		g = self.line_of_next_occurrence(tex, g, self.lily_packages)	# print "g = ", g

		# Add +1 to the preliminary mapping if the \usepackage{graphics} line of the .tex file is located before the mapping.
		# This last calculation yields the exact mapping.
		if mapping < g:
			return mapping
		else:
			return mapping + 1

	def run(self, edit, **args):
		texFile, texExt = os.path.splitext(self.view.file_name())
		if texExt.upper() not in (".TEX", ".LYTEX"):
			sublime.error_message("%s is not a TeX source file: cannot jump." % (os.path.basename(self.view.file_name()),))
			return
		quotes = "\""
		srcfile = texFile + u'.tex'
		root = getTeXRoot.get_tex_root(self.view.file_name())
		print "!TEX root = ", root
		rootName, rootExt = os.path.splitext(root)
		pdffile = rootName + u'.pdf'
		(line, col) = self.view.rowcol(self.view.sel()[0].end())
		# If we are mapping from a .LYTEX file to the PDF, we need to map to the .TEX file first.
		if texExt.upper() == ".LYTEX":
			line = self.map_lytex2tex(line, texFile.upper())
			print "New line: ", line
		print "Jump to ", line,col, "of ", srcfile
		# column is actually ignored up to 0.94
		# HACK? It seems we get better results incrementing line
		line += 1

		# Query view settings to see if we need to keep focus or let the PDF viewer grab it
		# By default, we keep it
		keep_focus = self.view.settings().get("keep focus",True)
		print keep_focus

		# platform-specific code:
		plat = sublime_plugin.sys.platform
		if plat == 'darwin':
			options = ["-r","-g"] if keep_focus else ["-r"]
			print "srcfile =", srcfile, "pdffile =", pdffile
			subprocess.Popen(["/Applications/Skim.app/Contents/SharedSupport/displayline"] + 
								options + [str(line), pdffile, srcfile])
		elif plat == 'win32':
			# determine if Sumatra is running, launch it if not
			print "Windows, Calling Sumatra"
			# hide console
			startupinfo = subprocess.STARTUPINFO()
			startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
			tasks = subprocess.Popen(["tasklist"], stdout=subprocess.PIPE,
					startupinfo=startupinfo).communicate()[0]
			# Popen returns a byte stream, i.e. a single line. So test simply:
			if "SumatraPDF.exe" not in tasks:
				print "Sumatra not running, launch it"
				self.view.window().run_command("view_pdf")
				time.sleep(0.5) # wait 1/2 seconds so Sumatra comes up
			setfocus = 0 if keep_focus else 1
			# First send an open command forcing reload, or ForwardSearch won't 
			# reload if the file is on a network share
			command = u'[Open(\"%s\",0,%d,1)]' % (pdffile,setfocus)
			print command
			self.view.run_command("send_dde",
					{ "service": "SUMATRA", "topic": "control", "command": command})
			# Now send ForwardSearch command
			command = "[ForwardSearch(\"%s\",\"%s\",%d,%d,0,%d)]" \
						% (pdffile, srcfile, line, col, setfocus)
			print command
			self.view.run_command("send_dde",
					{ "service": "SUMATRA", "topic": "control", "command": command})
		else: # Linux
			pass